import { EventDispatcher, Vector2 } from "three";
import { Configuration, configWallHeight, cornerTolerance } from "../utils/configuration";
import { EVENT_ACTION, EVENT_CORNER_ATTRIBUTES_CHANGED, EVENT_DELETED, EVENT_MOVED } from "../utils/events";
import { Utils } from "../utils/utils";
import Floorplan from "./floorplan";
import Room from "./room";
import Wall from "./wall";

/**
 * Corners are used to define Walls.
 */
export class Corner extends EventDispatcher {
    /**
     * Array of walls that are start walls
     **/
    startWalls: Wall[];
    /**
     * Array of walls that are end walls
     **/
    endWalls: Wall[];
    /**
     * Reference to the model floorplan
     **/
    floorplan: Floorplan;
    /**
     * The position in x dimension
     **/
    private _x: number;
    /**
     * The position in y dimension
     **/
    private _y: number;
    /**
     * The position as [Vector2](https://threejs.org/docs/#api/en/math/Vector2)
     **/
    private _location: Vector2;
    /**
     * The elevation at this corner
     **/
    private _elevation: number;
    /**
     * The id of this corner. Autogenerated the first time
     **/
    id: string;
    /**
     * Array of rooms that have walls using this corner
     **/
    attachedRooms: Room[];

    private _angles: number[];

    /**
     * Array of angle directions as [Vector2](https://threejs.org/docs/#api/en/math/Vector2)
     */
    private _angleDirections: Vector2[];

    private _startAngles: number[];

    private _endAngles: number[];

    private _cyclicNeighbors: Corner[];
    /**
     * A flag to indicate if something has changed about this corner
     **/
    private _hasChanged: boolean;

    /**
     * Constructs a corner.
     * @param floorplan The associated model floorplan.
     * @param x X coordinate.
     * @param y Y coordinate.
     * @param id An optional unique id. If not set, created internally.
     */
    constructor(floorplan: Floorplan, x: number, y: number, id?: string) {
        super();
        this.startWalls = [];
        this.endWalls = [];
        this.floorplan = floorplan;
        this._x = x;
        this._y = y;
        this._location = new Vector2(this._x, this._y);
        this._elevation = Configuration.getValue(configWallHeight);
        this.id = id || Utils.guide();
        this.attachedRooms = [];
        this._angles = [];
        this._angleDirections = [];
        this._startAngles = [];
        this._endAngles = [];
        this._cyclicNeighbors = [];
        this._hasChanged = false;
    }

    get uuid(): string {
        return this.id;
    }

    get startAngles(): number[] {
        return this._startAngles;
    }

    get endAngles(): number[] {
        return this._endAngles;
    }

    get angles(): number[] {
        return this._angles;
    }

    /**
     * @see https://threejs.org/docs/#api/en/math/Vector2
     */
    get angleDirections(): Vector2[] {
        return this._angleDirections;
    }

    /**
     * @see https://threejs.org/docs/#api/en/math/Vector2
     */
    get location(): Vector2 {
        return this._location;
    }

    /**
     * @see https://threejs.org/docs/#api/en/math/Vector2
     */
    set location(xy: Vector2) {
        this._location.x = xy.x;
        this._location.y = xy.y;
        this.x = xy.x;
        this.y = xy.y;
    }

    get x(): number {
        return this._x;
    }

    set x(value: number) {
        const oldvalue = this._x;
        if (Math.abs(value - this._x) > 1e-6) {
            this._hasChanged = true;
        }
        this._x = value;
        if (this._hasChanged) {
            this._location.x = this._x;
            this.updateAttachedRooms();
            //             this.floorplan.update(false);
            this.dispatchEvent({
                type: EVENT_CORNER_ATTRIBUTES_CHANGED,
                item: this,
                info: { from: oldvalue, to: this._x },
            });
        }
    }

    get y(): number {
        return this._y;
    }

    set y(value: number) {
        const oldvalue = this._y;
        if (Math.abs(value - this._y) > 1e-6) {
            this._hasChanged = true;
        }
        this._y = value;
        if (this._hasChanged) {
            this._location.y = this._y;
            this.updateAttachedRooms();
            //             this.floorplan.update(false);
            this.dispatchEvent({
                type: EVENT_CORNER_ATTRIBUTES_CHANGED,
                item: this,
                info: { from: oldvalue, to: this._y },
            });
        }
    }

    /**
     * @type {number} elevation The elevation value at this corner
     **/
    set elevation(value: number) {
        const oldvalue = this._elevation;
        if (value - this._elevation < 1e-6) {
            this._hasChanged = true;
        }
        this._elevation = value; // Dimensioning.cmFromMeasureRaw(number(value));
        if (this._hasChanged) {
            this.dispatchEvent({
                type: EVENT_CORNER_ATTRIBUTES_CHANGED,
                item: this,
                info: { from: oldvalue, to: this._elevation },
            });
        }
    }

    /**
     * @type {number} elevation The elevation value at this corner
     **/
    get elevation(): number {
        return this._elevation;
    }

    /**
     * @param room - The room that should be attached to this corner
     **/
    attachRoom(room: Room): void {
        if (room) {
            this.attachedRooms.push(room);
        }
    }

    /**
     * @returns Array of rooms attached to this corner
     **/
    getAttachedRooms(): Room[] {
        return this.attachedRooms;
    }

    /**
     * Clear all the rooms attached to this corner
     **/
    clearAttachedRooms(): void {
        this.attachedRooms = [];
    }

    fireAction(action: never): void {
        this.dispatchEvent({ type: EVENT_ACTION, item: this, action });
        //      this.actionCallbacks.fire(action)
    }

    /**
     *  @param tolerance - The tolerance value within which it will snap to adjacent corners
     *  @returns Contains keys x and y with true/false values
     *  @description The object with x and y that are boolean values to indicate if the snap happens in x and y
     */
    snapToAxis(tolerance: number): { x: boolean; y: boolean } {
        // try to snap this corner to an axis
        const snapped = { x: false, y: false };

        this.adjacentCorners().forEach((corner) => {
            if (Math.abs(corner.x - this.x) < tolerance) {
                this.x = corner.x;
                snapped.x = true;
            }
            if (Math.abs(corner.y - this.y) < tolerance) {
                this.y = corner.y;
                snapped.y = true;
            }
        });
        return snapped;
    }

    /**
     * Moves corner to new position.
     * @param newX The new x position.
     * @param newY The new y position.
     */
    move(newX: number, newY: number, mergeWithIntersections = false): void {
        //         this.x = newX;
        //         this.y = newY;
        this._x = newX;
        this._y = newY;
        this._location.x = newX;
        this._location.y = newY;

        if (mergeWithIntersections) {
            // The below line is crashing after makign the changes for curved walls
            // While release v1.0.0 is stable even with this line enabled
            this.mergeWithIntersected();
            if (this.floorplan.rooms.length < 10) {
                this.updateAttachedRooms(true);
            }
        }

        this.dispatchEvent({ type: EVENT_MOVED, item: this, position: new Vector2(newX, newY) });
        //      this.movedCallbacks.fire(this.x, this.y);

        this.startWalls.forEach((wall) => {
            wall.fireMoved();
        });

        this.endWalls.forEach((wall) => {
            wall.fireMoved();
        });
    }

    /**
     * Moves corner relatively to new position.
     * @param dx The delta x.
     * @param dy The delta y.
     */
    relativeMove(dx: number, dy: number): void {
        this.move(this.x + dx, this.y + dy);
    }

    /**
     * Dispatches an event when removed from the floorplan({@link Floorplan}) instance. The event object contains reference to this {@link Corner} instance as item.
     * @example
     * ```
     * let corner = new Corner(floorplan, 0, 0);
     * function cornerRemoved(e) { console.log('I WAS REMOVED FROM LOCATION ', e.item.x, e.item.y) };
     * corner.remove();
     * ```
     * @emits EVENT_DELETED
     **/
    remove(): void {
        this.dispatchEvent({ type: EVENT_DELETED, item: this });
    }

    /**
     * Removes all the connected corners and itself. This in essence removes all the walls({@link Wall}) this corner is connected to.
     * @example
     * ```
     * let corner1 = new Corner(floorplan, 0, 0);
     * let corner2 = new Corner(floorplan, 10, 0);
     * function cornerRemoved(e) { console.log('I WAS REMOVED FROM LOCATION ', e.item.x, e.item.y) } //Will log twice for two corners;
     * corner.removeAll();
     * ```
     **/
    removeAll(): void {
        let i = 0;
        for (i = 0; i < this.startWalls.length; i++) {
            this.startWalls[i].remove();
        }
        for (i = 0; i < this.endWalls.length; i++) {
            this.endWalls[i].remove();
        }
        this.remove();
    }

    // Angle is in degrees 0 - 360
    // TODO: Improve documentation and find return type.
    closestAngle(angle: number): { angle: number; point: Vector2 } {
        const neighbors = this.adjacentCorners();
        let delta = 999999;
        let closestAngle = 0;
        const point = new Vector2();

        for (const neighbour of neighbors) {
            // const wall = this.wallToOrFrom(neighbour);
            let neighbourAngle = neighbour.location.clone().sub(this.location).angle();
            neighbourAngle = (neighbourAngle * 180) / Math.PI;
            const diff = Math.abs(angle - neighbourAngle);
            if (diff < delta) {
                delta = diff;
                point.x = neighbour.location.x;
                point.y = neighbour.location.y;
                closestAngle = neighbourAngle;
            }
        }

        return { angle: closestAngle, point };
    }

    updateAngles(): void {
        const neighbors = this.adjacentCorners();
        this._angles = [];
        this._angleDirections = [];
        this._startAngles = [];
        this._endAngles = [];
        this._cyclicNeighbors = [];
        if (neighbors.length < 2) {
            return;
        }

        const start = this.location.clone();
        const points: Vector2[] = [];
        for (const neighbour of neighbors) {
            points.push(neighbour.location);
        }
        const indicesAndAngles = Utils.getCyclicOrder(points, start);
        const indices = indicesAndAngles.indices;
        const angles = indicesAndAngles.angles;
        //         var N = (indices.length%2 === 0)? (indices.length < 3) ? indices.length - 1 : indices.length : indices.length - 1;
        const N = indices.length < 3 ? 1 : indices.length;
        for (let i = 0; i < N; i++) {
            const next = (i + 1) % indices.length;
            const cindex = indices[i];
            const nindex = indices[next];

            // const _cwall: Wall = this.wallToOrFrom(neighbors[cindex]);
            // const _nwall: Wall = this.wallToOrFrom(neighbors[nindex]);

            const vectorA: Vector2 = points[cindex].clone().sub(start).normalize();
            const vectorB: Vector2 = points[nindex].clone().sub(start).normalize();
            const midVector: Vector2 = vectorA.add(vectorB).multiplyScalar(20.0);

            let diffAngle: number = Math.abs(angles[next] - angles[i]);
            diffAngle = diffAngle > 180 ? 360 - diffAngle : diffAngle;
            diffAngle = Math.round(diffAngle * 10) / 10;
            this._startAngles.push(angles[i]);
            this._endAngles.push(angles[next]);
            this._angles.push(diffAngle);
            this._angleDirections.push(midVector);
            this._cyclicNeighbors.push(neighbors[indices[i]]);
        }
    }

    /**
     * When a corner is moved from its location it will impact the connected rooms ({@link Room}) shape, thus their areas. This will update the rooms
     * @example
     * ```
     * let corner = new Corner(floorplan, 0, 0);
     * corner.move(10, 0);
     * ```
     **/
    updateAttachedRooms(explicit = false): void {
        if (!this._hasChanged && !explicit) {
            return;
        }
        this.attachedRooms.forEach((room) => {
            room.updateArea();
        });
        this._hasChanged = false;
    }

    /**
     * Gets the adjacent corners that are connected to this corner by walls ({@link Wall}).
     * @returns {Corner[]} Array of corners.
     */
    adjacentCorners(): Corner[] {
        const retArray = [];
        let i = 0;
        for (i = 0; i < this.startWalls.length; i++) {
            retArray.push(this.startWalls[i].getEnd());
        }
        for (i = 0; i < this.endWalls.length; i++) {
            retArray.push(this.endWalls[i].getStart());
        }
        return retArray;
    }

    /**
     * Checks if a wall is connected.
     * @param wall A wall.
     * @returns {boolean} in case of connection.
     */
    isWallConnected(wall: Wall): boolean {
        let i = 0;
        for (i = 0; i < this.startWalls.length; i++) {
            if (this.startWalls[i] === wall) {
                return true;
            }
        }
        for (i = 0; i < this.endWalls.length; i++) {
            if (this.endWalls[i] === wall) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns the distance between this corner and a point in 2d space
     * @param point
     * @see https://threejs.org/docs/#api/en/math/Vector2
     * @returns distance The distance
     **/
    distanceFrom(point: Vector2): number {
        const distance = Utils.distance(point, new Vector2(this.x, this.y));

        return distance;
    }

    /**
     * Gets the distance from a wall.
     * @param wall A wall.
     * @returns {number} distance The distance.
     */
    distanceFromWall(wall: Wall): number {
        const cPoint = new Vector2(this.x, this.y);

        return wall.distanceFrom(cPoint);
    }

    /**
     * Gets the distance from a corner.
     * @param corner A corner.
     * @returns {number} The distance.
     */
    distanceFromCorner(corner: Corner): number {
        return this.distanceFrom(new Vector2(corner.x, corner.y));
    }

    /**
     * Detaches a wall.
     * @param wall A wall.
     */
    detachWall(wall: Wall): void {
        Utils.removeValue(this.startWalls, wall);
        Utils.removeValue(this.endWalls, wall);

        if (this.startWalls.length === 0 && this.endWalls.length === 0) {
            this.remove();
        }
    }

    /**
     * Attaches a start wall.
     * @param wall A wall.
     */
    attachStart(wall: Wall): void {
        this.startWalls.push(wall);
    }

    /**
     * Attaches an end wall.
     * @param wall A wall.
     */
    attachEnd(wall: Wall): void {
        this.endWalls.push(wall);
    }

    /**
     * Get wall to corner.
     * @param corner A corner.
     * @returns The associated wall or null.
     */
    wallTo(corner: Corner): Wall {
        for (const wall of this.startWalls) {
            if (wall.getEnd() === corner) {
                return wall;
            }
        }

        return null;
    }

    /**
     * Get wall from corner.
     * @param  corner A corner.
     * @returns The associated wall or null.
     */
    wallFrom(corner: Corner): Wall {
        for (const wall of this.endWalls) {
            if (wall.getStart() === corner) {
                return wall;
            }
        }

        return null;
    }

    /**
     * Get wall to or from corner.
     * @param corner A corner.
     * @returns The associated wall or null.
     */
    wallToOrFrom(corner: Corner): Wall {
        return this.wallTo(corner) || this.wallFrom(corner);
    }

    /**
     * Get wall from corner.
     * @param corner A corner.
     */
    combineWithCorner(corner: Corner): void {
        let i = 0;
        // update position to other corner's
        //         this.x = corner.x;
        //         this.y = corner.y;
        this.move(corner.x, corner.y, false);
        // absorb the other corner's startWalls and endWalls
        for (i = corner.startWalls.length - 1; i >= 0; i--) {
            corner.startWalls[i].setStart(this);
        }
        for (i = corner.endWalls.length - 1; i >= 0; i--) {
            corner.endWalls[i].setEnd(this);
        }

        // delete the other corner
        corner.removeAll();
        this.removeDuplicateWalls();
        this.floorplan.update("combineWithCorners");
    }

    // TODO: Document this function
    mergeWithIntersected(_updateFloorPlan = true): boolean {
        let i = 0;
        // console.log('mergeWithIntersected for object: ' + this.type);
        // check corners
        for (i = 0; i < this.floorplan.getCorners().length; i++) {
            const corner = this.floorplan.getCorners()[i];
            if (this.distanceFromCorner(corner) < cornerTolerance && corner !== this) {
                this.combineWithCorner(corner);
                return true;
            }
        }
        // check walls
        for (i = 0; i < this.floorplan.getWalls().length; i++) {
            const wall = this.floorplan.getWalls()[i];
            if (this.distanceFromWall(wall) < cornerTolerance && !this.isWallConnected(wall)) {
                // update position to be on wall
                const intersection = Utils.closestPointOnLine(
                    new Vector2(this.x, this.y),
                    wall.getStart().location,
                    wall.getEnd().location
                );

                this.floorplan.newWall(this, wall.getEnd());
                wall.setEnd(this);

                // The below line is crashing because of recursive. This function mergeWithIntersected is called
                // From move(newX, newY) method. Now if we call move(newX, newY) from inside this method
                // It will lead to recursion. So ensure in the move(newX, newY) method mergeWithIntersected is not called
                // Hence added a third parameter to move(newX, newY, mergeWithIntersections) that is a boolean value
                // Send this boolean value as false to avoid recursion crashing of the application
                this.move(intersection.x, intersection.y, false); // Causes Recursion if third parameter is true

                this.floorplan.update("mergeWithIntersected");
                return true;
            }
        }
        return false;
    }

    /**
     * Ensure we do not have duplicate walls (i.e. same start and end points)
     **/
    removeDuplicateWalls(): void {
        let i = 0;
        // delete the wall between these corners, if it exists
        const wallEndpoints = {};
        const wallStartpoints = {};
        for (i = this.startWalls.length - 1; i >= 0; i--) {
            if (this.startWalls[i].getEnd() === this) {
                // remove zero length wall
                this.startWalls[i].remove();
            } else if (this.startWalls[i].getEnd().id in wallEndpoints) {
                // remove duplicated wall
                this.startWalls[i].remove();
            } else {
                wallEndpoints[this.startWalls[i].getEnd().id] = true;
            }
        }
        for (i = this.endWalls.length - 1; i >= 0; i--) {
            if (this.endWalls[i].getStart() === this) {
                // removed zero length wall
                this.endWalls[i].remove();
            } else if (this.endWalls[i].getStart().id in wallStartpoints) {
                // removed duplicated wall
                this.endWalls[i].remove();
            } else {
                wallStartpoints[this.endWalls[i].getStart().id] = true;
            }
        }
    }
}
export default Corner;
